### SRC CONTENT DUMP - 2026-02-02 12:48:27


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\__pycache__\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\app.py
============================================================
from __future__ import annotations

import sys
from PySide6.QtWidgets import QApplication

from src.ui.qt.theme import apply_museum_theme
from src.ui.qt.main_window import MainWindow


def _set_windows_app_id(app_id: str) -> None:
    """
    Ensures Windows taskbar grouping + App identity are correct.
    Safe no-op on non-Windows platforms.
    """
    if sys.platform != "win32":
        return
    try:
        import ctypes  # stdlib
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)
    except Exception:
        pass


def main() -> int:
    # Set AppUserModelID before creating any windows (Windows taskbar identity)
    _set_windows_app_id("nhmc.labelforge")

    app = QApplication(sys.argv)

    # Qt application identity (used by OS/UI in various places)
    app.setApplicationName("LabelForge")
    app.setOrganizationName("NHMC")
    app.setOrganizationDomain("nhmc.uoc.gr")

    apply_museum_theme(app)

    w = MainWindow()
    w.show()
    return app.exec()


if __name__ == "__main__":
    raise SystemExit(main())



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\domain\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\domain\models.py
============================================================
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List


@dataclass
class LevelEntry:
    level: int
    code: str = ""
    name: str = ""


@dataclass
class LabelDocument:
    title: str = "Cabinet Inventory Label"
    cabinet_section: str = ""
    level1: LevelEntry = field(default_factory=lambda: LevelEntry(level=1))
    level2_list: List[LevelEntry] = field(default_factory=list)



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\domain\normalize.py
============================================================
from __future__ import annotations

import re


_SUFFIX_RE = re.compile(r"^\s*(\d{1,3})\s*$")  # 1..999 suffix


def expand_child_code(parent_code: str, child_code: str, delimiter: str = ".") -> str:
    p = (parent_code or "").strip()
    c = (child_code or "").strip()

    if not c:
        return c
    if not p:
        return c

    # if already contains delimiter, assume it's a full code
    if delimiter and delimiter in c:
        return c

    m = _SUFFIX_RE.match(c)
    if not m:
        return c

    suffix = str(int(m.group(1)))  # "06" -> "6"
    return f"{p}{delimiter}{suffix}"



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\domain\units.py
============================================================
from __future__ import annotations

# PDF points: 72 points per inch
# 1 inch = 2.54 cm
def cm_to_pt(cm: float) -> float:
    return float(cm) * 72.0 / 2.54



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\resources\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\resources\icons\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\cache\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\cache\cache_store.py
============================================================
from __future__ import annotations

import json
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List


def default_cache_path() -> Path:
    base = Path(os.environ.get("APPDATA", ".")) / "LabelApp"
    base.mkdir(parents=True, exist_ok=True)
    return base / "cache.json"


@dataclass
class CacheDB:
    # keys are field identifiers, values are a list of recent strings
    values: Dict[str, List[str]] = field(default_factory=dict)


def load_cache(path: Path | None = None) -> CacheDB:
    path = path or default_cache_path()
    if not path.exists():
        return CacheDB()
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
        if isinstance(data, dict) and isinstance(data.get("values"), dict):
            return CacheDB(values={k: list(v) for k, v in data["values"].items()})
    except Exception:
        pass
    return CacheDB()


def save_cache(db: CacheDB, path: Path | None = None) -> None:
    path = path or default_cache_path()
    payload = {"values": db.values}
    path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")


def remember(db: CacheDB, field: str, text: str, limit: int = 50) -> None:
    t = " ".join((text or "").strip().split())
    if not t:
        return
    lst = db.values.setdefault(field, [])
    # de-dupe case-insensitively, keep newest
    lowered = [x.lower() for x in lst]
    if t.lower() in lowered:
        idx = lowered.index(t.lower())
        lst.pop(idx)
    lst.insert(0, t)
    del lst[limit:]


def suggest(db: CacheDB, field: str, prefix: str, limit: int = 12) -> List[str]:
    p = (prefix or "").strip().lower()
    items = db.values.get(field, [])
    if not p:
        return items[:limit]

    starts = [x for x in items if x.lower().startswith(p)]
    contains = [x for x in items if (p in x.lower()) and not x.lower().startswith(p)]
    out = starts + contains
    return out[:limit]



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\export\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\export\pdf_exporter.py
============================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.pdfbase.pdfmetrics import stringWidth
from reportlab.pdfgen.canvas import Canvas


@dataclass
class PdfExportOptions:
    pagesize: Tuple[float, float] = A4
    template_id: str = "classic"  # classic|modern|institutional|boxed|compact|code_first|outline|two_column

    # Section label shown above the table/outline. "" means none.
    section_title: str = ""

    # Auto-flow to two columns on the SAME page when content would otherwise spill to next page.
    auto_two_columns: bool = True

    margin_cm: float = 1.6
    header_gap_pt: float = 12.0
    row_pad_pt: float = 4.0

    font_name: str = "Times-Roman"
    font_bold: str = "Times-Bold"
    font_italic: str = "Times-Italic"
    title_size: float = 18.0
    meta_size: float = 10.5
    section_size: float = 11.5
    max_font: float = 12.0
    min_font: float = 8.0
    leading_mult: float = 1.22


def _apply_template(opts: PdfExportOptions) -> PdfExportOptions:
    tid = (opts.template_id or "classic").strip().lower()

    # Default section title policy: keep labels clean (no "Hierarchy" by default).
    if tid == "outline":
        # Outline often benefits from a label, but only if user wants one.
        # If user leaves it blank, keep it blank.
        pass
    else:
        opts.section_title = opts.section_title or ""

    if tid in ("modern", "compact", "two_column"):
        opts.font_name = "Helvetica"
        opts.font_bold = "Helvetica-Bold"
        opts.font_italic = "Helvetica-Oblique"
        opts.title_size = 17.0
        opts.meta_size = 10.0
        opts.section_size = 11.0
        opts.leading_mult = 1.20
        opts.margin_cm = max(opts.margin_cm, 1.7)

    elif tid in ("institutional", "boxed", "classic", "code_first", "outline"):
        opts.font_name = "Times-Roman"
        opts.font_bold = "Times-Bold"
        opts.font_italic = "Times-Italic"
        opts.leading_mult = 1.22
        opts.margin_cm = max(opts.margin_cm, 1.6)
        if tid == "institutional":
            opts.title_size = 16.5
        elif tid == "boxed":
            opts.title_size = 16.5
        elif tid == "outline":
            opts.title_size = 16.0
        else:
            opts.title_size = 18.0

    return opts


def _wrap_words(text: str, font: str, size: float, max_w: float) -> List[str]:
    words = (text or "").split()
    if not words:
        return [""]

    lines: List[str] = []
    cur = ""
    for w in words:
        test = (cur + " " + w).strip()
        if stringWidth(test, font, size) <= max_w:
            cur = test
        else:
            if cur:
                lines.append(cur)
            if stringWidth(w, font, size) > max_w:
                chunk = ""
                for ch in w:
                    t2 = chunk + ch
                    if stringWidth(t2, font, size) <= max_w:
                        chunk = t2
                    else:
                        if chunk:
                            lines.append(chunk)
                        chunk = ch
                cur = chunk
            else:
                cur = w
    if cur:
        lines.append(cur)
    return lines


def _fit_paragraph(
    text: str,
    font: str,
    max_w: float,
    max_h: float,
    max_size: float,
    min_size: float,
    leading_mult: float,
) -> Tuple[float, List[str], float]:
    t = (text or "").strip()
    if not t:
        size = max_size
        leading = size * leading_mult
        return size, [""], leading

    size = max_size
    while size >= min_size:
        lines = _wrap_words(t, font, size, max_w)
        leading = size * leading_mult
        if leading * len(lines) <= max_h:
            return size, lines, leading
        size -= 0.5

    lines = _wrap_words(t, font, min_size, max_w)
    leading = min_size * leading_mult
    return min_size, lines, leading


def _draw_wrapped(
    c: Canvas,
    x: float,
    y_top: float,
    w: float,
    h: float,
    text: str,
    font: str,
    opts: PdfExportOptions,
    align: str = "left",
    bold: bool = False,
) -> None:
    face = opts.font_bold if bold else font
    size, lines, leading = _fit_paragraph(text, face, w, h, opts.max_font, opts.min_font, opts.leading_mult)
    c.setFont(face, size)

    y = y_top - size
    for ln in lines:
        if align == "center":
            c.drawCentredString(x + w / 2.0, y, ln)
        elif align == "right":
            c.drawRightString(x + w, y, ln)
        else:
            c.drawString(x, y, ln)
        y -= leading


def _walk_tree(nodes: List[Dict[str, Any]], level: int = 1) -> List[Tuple[int, str, str]]:
    out: List[Tuple[int, str, str]] = []
    for n in nodes:
        out.append((level, (n.get("code") or "").strip(), (n.get("name") or "").strip()))
        kids = n.get("children") or []
        out.extend(_walk_tree(kids, level + 1))
    return out


def _doc_rows(doc: Any) -> List[Tuple[int, str, str]]:
    hierarchy = getattr(doc, "hierarchy", None)
    if isinstance(hierarchy, list):
        rows = _walk_tree(hierarchy, 1)
        if rows:
            return rows
    return [(1, "", "")]


def _group_by_level1(rows: List[Tuple[int, str, str]]) -> List[List[Tuple[int, str, str]]]:
    """
    Group rows into Level-1 blocks: [ (lvl1,...), (lvl2,...), ... ] until next lvl1.
    If data doesn't start with lvl1, we treat it as one group.
    """
    groups: List[List[Tuple[int, str, str]]] = []
    cur: List[Tuple[int, str, str]] = []

    for r in rows:
        lvl = int(r[0])
        if lvl == 1:
            if cur:
                groups.append(cur)
            cur = [r]
        else:
            if not cur:
                cur = []
            cur.append(r)

    if cur:
        groups.append(cur)

    if not groups:
        return [rows]
    return groups


def export_label_pdf(doc: Any, out_path: str, opts: Optional[PdfExportOptions] = None) -> None:
    opts = _apply_template(opts or PdfExportOptions())
    tid = (opts.template_id or "classic").strip().lower()

    pagesize = opts.pagesize or A4
    c = Canvas(out_path, pagesize=pagesize)
    W, H = pagesize
    margin = opts.margin_cm * cm
    x0 = margin
    x1 = W - margin
    content_w = x1 - x0

    title = (getattr(doc, "title", "") or "").strip() or "NHMC Label"
    cab = (getattr(doc, "cabinet_section", "") or "").strip()
    rows = _doc_rows(doc)

    gap = 12.0
    indent_step = 10.0

    template_draws_own_section_title = tid in ("outline", "two_column")

    def header_footer(cont: bool = False) -> float:
        y = H - margin

        if tid == "institutional":
            c.setFont(opts.font_name, 9.0)
            c.drawString(x0, y + 10, "NHMC — Natural History Museum of Crete")
            c.drawRightString(x1, y + 10, "NHMC-Labelling")

        c.setFont(opts.font_bold, opts.title_size)
        c.drawCentredString(W / 2.0, y, title)
        y -= (opts.title_size + 6)

        if cab:
            c.setFont(opts.font_italic, opts.meta_size)
            c.drawCentredString(W / 2.0, y, f"Cabinet Section: {cab}")
            y -= (opts.meta_size + 8)
        else:
            y -= 6

        c.setLineWidth(0.8)
        c.line(x0, y, x1, y)
        y -= opts.header_gap_pt

        if tid != "boxed" and (not template_draws_own_section_title) and (opts.section_title or "").strip():
            c.setFont(opts.font_bold, opts.section_size)
            c.drawString(x0, y, (opts.section_title or "").strip() + (" (cont.)" if cont else ""))
            y -= (opts.section_size + 8)

        if tid == "institutional":
            c.setLineWidth(0.6)
            c.setFont(opts.font_name, 9.0)
            c.drawString(x0, margin - 10, "Generated by NHMC-Labelling")
            c.drawRightString(x1, margin - 10, f"Page {c.getPageNumber()}")

        return y

    def new_page() -> float:
        c.showPage()
        return header_footer(cont=True)

    y = header_footer(False)

    # ---------------- OUTLINE ----------------
    if tid == "outline":
        st = (opts.section_title or "").strip()
        if st:
            c.setFont(opts.font_bold, opts.section_size)
            c.drawString(x0, y, st)
            y -= (opts.section_size + 10)

        bullet_indent = 10.0
        line_h = 14.0

        for lvl, code, name in rows:
            if y - (line_h + 6) < margin:
                y = new_page()
                if st:
                    c.setFont(opts.font_bold, opts.section_size)
                    c.drawString(x0, y, st + " (cont.)")
                    y -= (opts.section_size + 10)

            indent = (lvl - 1) * bullet_indent
            line = f"• {code} — {name}".strip()
            _draw_wrapped(c, x0 + indent, y, content_w - indent, line_h + 10, line, opts.font_name, opts, bold=(lvl == 1))
            y -= (line_h + 6)

        c.save()
        return

    # ---------------- EXPLICIT TWO COLUMN TEMPLATE ----------------
    if tid == "two_column":
        st = (opts.section_title or "").strip()
        if st:
            c.setFont(opts.font_bold, opts.section_size)
            c.drawString(x0, y, st)
            y -= (opts.section_size + 10)

        col_gap = 18.0
        col_w = (content_w - col_gap) / 2.0

        def draw_headers(x_left: float, y_top: float) -> float:
            c.setFont(opts.font_bold, 10.0)
            c.drawString(x_left, y_top, "Code")
            c.drawString(x_left + 110, y_top, "Name")
            y2 = y_top - 10
            c.setLineWidth(0.6)
            c.line(x_left, y2, x_left + col_w, y2)
            return y2 - 10

        y = draw_headers(x0, y)
        _ = draw_headers(x0 + col_w + col_gap, y + 20)

        left_rows = rows[0::2]
        right_rows = rows[1::2]

        i = 0
        while i < max(len(left_rows), len(right_rows)):
            if y - 28 < margin:
                y = new_page()
                if st:
                    c.setFont(opts.font_bold, opts.section_size)
                    c.drawString(x0, y, st + " (cont.)")
                    y -= (opts.section_size + 10)
                y = draw_headers(x0, y)
                _ = draw_headers(x0 + col_w + col_gap, y + 20)

            if i < len(left_rows):
                lvl, code, name = left_rows[i]
                indent = (lvl - 1) * 8.0
                c.setFont(opts.font_bold if lvl == 1 else opts.font_name, 9.5)
                c.drawString(x0 + indent, y, code)
                c.setFont(opts.font_name, 9.0)
                c.drawString(x0 + 110 + indent, y, name[:60])

            if i < len(right_rows):
                lvl, code, name = right_rows[i]
                indent = (lvl - 1) * 8.0
                xR = x0 + col_w + col_gap
                c.setFont(opts.font_bold if lvl == 1 else opts.font_name, 9.5)
                c.drawString(xR + indent, y, code)
                c.setFont(opts.font_name, 9.0)
                c.drawString(xR + 110 + indent, y, name[:60])

            y -= 22
            i += 1

        c.save()
        return

    # ---------------- TABLE FAMILY (with auto 2-column flow) ----------------
    dense = (tid == "compact")
    code_first = (tid == "code_first")
    boxed = (tid == "boxed")

    row_base_h = 14.0 if dense else 18.0
    max_row_h = 72.0

    # --- boxed cabinet block ---
    if boxed:
        box_h = 46
        if y - box_h < margin:
            y = new_page()

        c.setLineWidth(0.9)
        c.roundRect(x0, y - box_h, content_w, box_h, 6, stroke=1, fill=0)
        c.setFont(opts.font_bold, 11.0)
        c.drawString(x0 + 10, y - 16, "Cabinet Section")
        c.setFont(opts.font_name, 10.0)
        c.drawString(x0 + 10, y - 32, cab or "-")
        y -= (box_h + 14)

        st = (opts.section_title or "").strip()
        if st:
            c.setFont(opts.font_bold, opts.section_size)
            c.drawString(x0, y, st)
            y -= (opts.section_size + 10)

    def row_height(code: str, name: str, code_col_w: float, name_col_w: float) -> float:
        _, code_lines, code_leading = _fit_paragraph(code, opts.font_name, code_col_w, max_row_h, opts.max_font, opts.min_font, opts.leading_mult)
        _, name_lines, name_leading = _fit_paragraph(name, opts.font_name, name_col_w, max_row_h, opts.max_font, opts.min_font, opts.leading_mult)
        needed_h = max(len(code_lines) * code_leading, len(name_lines) * name_leading, row_base_h) + opts.row_pad_pt
        return needed_h

    def draw_table_headers(x_left: float, y_top: float, col_w: float, code_col_w: float, name_col_w: float) -> float:
        c.setLineWidth(0.6)
        c.setFont(opts.font_bold, 10.5)
        c.drawString(x_left, y_top, "Code")
        c.drawString(x_left + code_col_w + gap, y_top, "Name")
        y2 = y_top - 10
        c.line(x_left, y2, x_left + col_w, y2)
        return y2 - 8

    def draw_one_row(x_left: float, y_top: float, col_w: float, code_col_w: float, name_col_w: float, lvl: int, code: str, name: str) -> float:
        indent = (lvl - 1) * indent_step
        x_code = x_left + indent
        x_name = x_left + indent + code_col_w + gap

        h = row_height(code, name, code_col_w, name_col_w)
        code_bold = (lvl == 1) or code_first

        _draw_wrapped(c, x_code, y_top, code_col_w, h, code, opts.font_name, opts, align="left", bold=code_bold)
        _draw_wrapped(c, x_name, y_top, name_col_w, h, name, opts.font_name, opts, align="left", bold=False)

        y_next = y_top - h
        c.setLineWidth(0.35 if tid in ("modern", "compact") else 0.4)
        c.line(x_left, y_next + 1.5, x_left + col_w, y_next + 1.5)
        y_next -= (4.0 if dense else 6.0)
        return y_next

    # Build Level-1 groups so we can keep them together across columns/pages.
    groups = _group_by_level1(rows)

    # Determine whether we should use 1 or 2 columns.
    # We decide by checking if everything fits in one column height.
    def total_height_for_groups(col_w: float) -> float:
        code_col_w = max(150.0, col_w * (0.34 if code_first else 0.28))
        name_col_w = col_w - code_col_w - gap

        h = 0.0
        # headers height: roughly 18
        h += 18.0
        for g in groups:
            for (lvl, code, name) in g:
                h += row_height(code, name, code_col_w, name_col_w)
                h += (4.0 if dense else 6.0)
        return h

    y_start = y
    col_height_available = y_start - margin

    use_two_cols = False
    if opts.auto_two_columns:
        # estimate one-column content height
        one_col_w = content_w
        if total_height_for_groups(one_col_w) > col_height_available:
            use_two_cols = True

    # Column geometry
    col_gap = 18.0
    if use_two_cols:
        col_w = (content_w - col_gap) / 2.0
        col_xs = [x0, x0 + col_w + col_gap]
    else:
        col_w = content_w
        col_xs = [x0]

    # Draw headers for the first column on the current page
    code_col_w = max(150.0, col_w * (0.34 if code_first else 0.28))
    name_col_w = col_w - code_col_w - gap

    col_index = 0
    x_left = col_xs[col_index]
    y = draw_table_headers(x_left, y, col_w, code_col_w, name_col_w)

    def start_new_column_or_page() -> Tuple[int, float, float]:
        nonlocal col_index, x_left, y, code_col_w, name_col_w
        if use_two_cols and col_index == 0:
            col_index = 1
            x_left = col_xs[col_index]
            # reset y to start of table area on same page
            y = y_start
            y = draw_table_headers(x_left, y, col_w, code_col_w, name_col_w)
            return col_index, x_left, y

        # new page
        y = new_page()
        y_start_local = y  # table starts at new header y
        # reset columns
        col_index = 0
        x_left = col_xs[col_index]
        y = y_start_local
        y = draw_table_headers(x_left, y, col_w, code_col_w, name_col_w)
        return col_index, x_left, y

    # Render group-by-group; never split a Level-1 group across columns if possible.
    for g in groups:
        # Compute group height in this column width
        g_h = 0.0
        for (lvl, code, name) in g:
            g_h += row_height(code, name, code_col_w, name_col_w)
            g_h += (4.0 if dense else 6.0)

        # If group doesn't fit in remaining space, move to next column/page.
        if (y - g_h) < margin:
            # If the group WOULD fit in a fresh column, move it as a block.
            fresh_y = y_start
            if (fresh_y - g_h) >= margin:
                start_new_column_or_page()
            else:
                # group too tall to fit in a fresh column:
                # we still move to next page, and if it still doesn't fit we will continue,
                # but we will REPEAT the Level-1 header row at the start of the new column/page
                # so lvl1 is never "separated".
                start_new_column_or_page()

        # Draw the group rows; if we *still* overflow mid-group (very tall group),
        # repeat lvl1 row on continuation.
        lvl1_row = None
        if g and int(g[0][0]) == 1:
            lvl1_row = g[0]

        first_row = True
        for (lvl, code, name) in g:
            h = row_height(code, name, code_col_w, name_col_w) + (4.0 if dense else 6.0)
            if (y - h) < margin:
                # continuation
                start_new_column_or_page()
                # repeat lvl1 row (if we have it) before continuing children
                if lvl1_row and not first_row:
                    y = draw_one_row(x_left, y, col_w, code_col_w, name_col_w, int(lvl1_row[0]), lvl1_row[1], lvl1_row[2])
            y = draw_one_row(x_left, y, col_w, code_col_w, name_col_w, lvl, code, name)
            first_row = False

    c.save()



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\rules\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\rules\engine.py
============================================================
from __future__ import annotations

from typing import List, Optional, Tuple

from src.services.rules.rules_types import RulesWorkbook, MappingRow, DefaultChildRow


def lookup_mapping(rules: RulesWorkbook, profile_id: str, level: int, code: str) -> Optional[MappingRow]:
    if not rules or not profile_id:
        return None
    key = (profile_id, level, (code or "").strip().lower())
    return rules.mappings.get(key)


def default_children_for(
    rules: RulesWorkbook,
    profile_id: str,
    parent_level: int,
    parent_code: str,
    child_level: int,
) -> List[DefaultChildRow]:
    if not rules or not profile_id:
        return []
    key = (profile_id, parent_level, (parent_code or "").strip().lower(), child_level)
    return list(rules.default_children.get(key, []))



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\rules\excel_loader.py
============================================================
from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Tuple

from openpyxl import load_workbook

from src.services.rules.rules_types import (
    RulesWorkbook, RulesProfile, MappingRow, DefaultChildRow
)


def _norm(s: Any) -> str:
    if s is None:
        return ""
    return " ".join(str(s).strip().split())


def _to_int(x: Any, default: int = 0) -> int:
    try:
        return int(str(x).strip())
    except Exception:
        return default


def _read_table(ws) -> Tuple[List[str], List[List[Any]]]:
    rows = list(ws.iter_rows(values_only=True))
    if not rows:
        return [], []
    headers = [(_norm(c)).lower() for c in (rows[0] or [])]
    data = [list(r) for r in rows[1:] if any((_norm(v) for v in (r or [])))]
    return headers, data


def _idx_map(headers: List[str]) -> Dict[str, int]:
    return {h: i for i, h in enumerate(headers) if h}


def _get(row: List[Any], idx: Dict[str, int], name: str) -> Any:
    j = idx.get(name.lower())
    if j is None or j >= len(row):
        return None
    return row[j]


def _parse_profiles_format(wb) -> RulesWorkbook:
    out = RulesWorkbook()

    # ---- Profiles ----
    if "Profiles" not in wb.sheetnames:
        raise ValueError("rules.xlsx is missing required sheet: Profiles")

    ws = wb["Profiles"]
    headers, data = _read_table(ws)
    idx = _idx_map(headers)

    for r in data:
        pid = _norm(_get(r, idx, "profile_id"))
        if not pid:
            continue

        pname = _norm(_get(r, idx, "profile_name")) or pid
        level_count = _to_int(_get(r, idx, "level_count"), 2)

        level_labels: Dict[int, str] = {}
        for lv in range(1, 7):
            lab = _norm(_get(r, idx, f"level{lv}_label"))
            if lv <= level_count:
                level_labels[lv] = lab or f"Level {lv}"

        delim = _norm(_get(r, idx, "code_delimiter")) or "."
        if len(delim) != 1:
            delim = "."

        prof = RulesProfile(
            profile_id=pid,
            profile_name=pname,
            level_count=level_count,
            level_labels=level_labels,
            code_delimiter=delim,
            code_regex=_norm(_get(r, idx, "code_regex")),
            notes=_norm(_get(r, idx, "notes")),
        )
        out.profiles[pid] = prof

    # ---- LevelMappings ----
    if "LevelMappings" in wb.sheetnames:
        ws = wb["LevelMappings"]
        headers, data = _read_table(ws)
        idx = _idx_map(headers)

        for r in data:
            pid = _norm(_get(r, idx, "profile_id"))
            if not pid:
                continue
            level = _to_int(_get(r, idx, "level"), 0)
            code = _norm(_get(r, idx, "code"))
            name = _norm(_get(r, idx, "name"))
            locked = str(_norm(_get(r, idx, "locked") or "TRUE")).strip().lower() not in ("0", "false", "no")

            if level <= 0 or not code:
                continue

            mr = MappingRow(profile_id=pid, level=level, code=code, name=name, locked=locked)
            out.mappings[(pid, level, code.strip().lower())] = mr

    # ---- DefaultChildren ----
    if "DefaultChildren" in wb.sheetnames:
        ws = wb["DefaultChildren"]
        headers, data = _read_table(ws)
        idx = _idx_map(headers)

        for r in data:
            pid = _norm(_get(r, idx, "profile_id"))
            if not pid:
                continue
            parent_level = _to_int(_get(r, idx, "parent_level"), 0)
            child_level = _to_int(_get(r, idx, "child_level"), 0)
            parent_code = _norm(_get(r, idx, "parent_code"))
            child_code = _norm(_get(r, idx, "child_code"))
            child_name = _norm(_get(r, idx, "child_name"))
            if not (parent_level and child_level and parent_code and child_code):
                continue

            dc = DefaultChildRow(
                profile_id=pid,
                parent_level=parent_level,
                parent_code=parent_code,
                child_level=child_level,
                child_code=child_code,
                child_name=child_name,
            )
            key = (pid, parent_level, parent_code.strip().lower(), child_level)
            out.default_children.setdefault(key, []).append(dc)

    # ---- Settings ----
    if "Settings" in wb.sheetnames:
        ws = wb["Settings"]
        headers, data = _read_table(ws)
        idx = _idx_map(headers)
        for r in data:
            k = _norm(_get(r, idx, "key"))
            v = _norm(_get(r, idx, "value"))
            if k:
                out.settings[k] = v

    return out


def _parse_simple_authority_format(wb) -> RulesWorkbook:
    """
    Supports the 'human' workbook:
      - Profile sheet: Field | Value
      - Level 1 sheet: Code | Name
      - Level 2 sheet: Parent code | Code (suffix) | Name
      - Optional Level 3/4: same parent+suffix structure
    """
    out = RulesWorkbook()

    if "Profile" not in wb.sheetnames or "Level 1" not in wb.sheetnames:
        raise ValueError("Simple authority workbook must contain sheets: Profile and Level 1")

    # ---- Profile ----
    ws = wb["Profile"]
    headers, data = _read_table(ws)

    # Expect simple key/value in first two columns, tolerate header row
    kv: Dict[str, str] = {}
    for r in data:
        k = _norm(r[0] if len(r) > 0 else "")
        v = _norm(r[1] if len(r) > 1 else "")
        if k:
            kv[k.lower()] = v

    institution = kv.get("institution", "")
    discipline = kv.get("discipline", "")
    delim = kv.get("code delimiter", ".") or "."
    if len(delim) != 1:
        delim = "."

    level_count = _to_int(kv.get("number of levels", 2), 2)
    level_count = max(2, min(level_count, 6))

    pad_l1 = _to_int(kv.get("pad level 1 codes to", 2), 2)
    pad_l1 = max(1, min(pad_l1, 6))

    level_labels: Dict[int, str] = {}
    for lv in range(1, level_count + 1):
        nm = kv.get(f"level {lv} name", "") or kv.get(f"level {lv} label", "")
        level_labels[lv] = nm or f"Level {lv}"

    # One default profile
    pid = "default"
    pname = (discipline or "Authority Profile").strip() or "Authority Profile"
    out.profiles[pid] = RulesProfile(
        profile_id=pid,
        profile_name=pname,
        level_count=level_count,
        level_labels=level_labels,
        code_delimiter=delim,
        code_regex="",
        notes="",
    )

    # Store institution/discipline as settings so UI can show them
    if institution:
        out.settings["institution"] = institution
    if discipline:
        out.settings["discipline"] = discipline
    out.settings["pad_level1"] = str(pad_l1)

    # Helper: normalize L1 codes (padding)
    def norm_l1(code: str) -> str:
        c = (code or "").strip()
        if c.isdigit():
            return str(int(c)).zfill(pad_l1)
        return c

    # ---- Level 1 mappings ----
    ws = wb["Level 1"]
    headers, data = _read_table(ws)
    idx = _idx_map(headers)

    # Fallback if headers missing: assume first 2 columns
    code_key = "code" if "code" in idx else headers[0] if headers else "code"
    name_key = "name" if "name" in idx else headers[1] if len(headers) > 1 else "name"

    for r in data:
        code = _norm(_get(r, idx, code_key) if idx else (r[0] if len(r) > 0 else ""))
        name = _norm(_get(r, idx, name_key) if idx else (r[1] if len(r) > 1 else ""))
        if not code:
            continue
        code = norm_l1(code)
        mr = MappingRow(profile_id=pid, level=1, code=code, name=name, locked=True)
        out.mappings[(pid, 1, code.lower())] = mr

    # ---- Level 2..N mappings ----
    for lv in range(2, level_count + 1):
        sheet = f"Level {lv}"
        if sheet not in wb.sheetnames:
            continue

        ws = wb[sheet]
        headers, data = _read_table(ws)
        idx = _idx_map(headers)

        # Expected columns
        # parent code | code (suffix) | name
        for r in data:
            parent = _norm(_get(r, idx, "parent code") if idx else (r[0] if len(r) > 0 else ""))
            suffix = _norm(_get(r, idx, "code (suffix)") if idx and "code (suffix)" in idx else (_get(r, idx, "code") if idx else (r[1] if len(r) > 1 else "")))
            name = _norm(_get(r, idx, "name") if idx else (r[2] if len(r) > 2 else ""))

            if not parent or not suffix:
                continue

            # Parent for level 2 is L1, so normalize padding
            if lv == 2:
                parent = norm_l1(parent)

            # Build full code: parent + delimiter + suffix (unless suffix already contains delimiter)
            full = suffix if (delim in suffix) else f"{parent}{delim}{str(int(suffix)) if suffix.isdigit() else suffix}"

            mr = MappingRow(profile_id=pid, level=lv, code=full, name=name, locked=True)
            out.mappings[(pid, lv, full.lower())] = mr

    return out


def load_rules_xlsx(path: str | Path) -> RulesWorkbook:
    path = Path(path)
    if not path.exists():
        raise FileNotFoundError(f"Rules file not found: {path}")

    wb = load_workbook(path, data_only=True)

    # If it looks like the old rules.xlsx format, parse that.
    if "Profiles" in wb.sheetnames:
        return _parse_profiles_format(wb)

    # Otherwise try the simple authority workbook format.
    return _parse_simple_authority_format(wb)



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\services\rules\rules_types.py
============================================================
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple


@dataclass(frozen=True)
class RulesProfile:
    profile_id: str
    profile_name: str
    level_count: int
    level_labels: Dict[int, str]
    code_delimiter: str = "."          # NEW (default ".")
    code_regex: str = ""               # optional validation
    notes: str = ""


@dataclass(frozen=True)
class MappingRow:
    profile_id: str
    level: int
    code: str
    name: str
    locked: bool = True


@dataclass(frozen=True)
class DefaultChildRow:
    profile_id: str
    parent_level: int
    parent_code: str
    child_level: int
    child_code: str
    child_name: str


@dataclass
class RulesWorkbook:
    profiles: Dict[str, RulesProfile] = field(default_factory=dict)
    # key: (profile_id, level, code_lower) -> MappingRow
    mappings: Dict[Tuple[str, int, str], MappingRow] = field(default_factory=dict)
    # key: (profile_id, parent_level, parent_code_lower, child_level) -> list[DefaultChildRow]
    default_children: Dict[Tuple[str, int, str, int], List[DefaultChildRow]] = field(default_factory=dict)
    settings: Dict[str, str] = field(default_factory=dict)

    def get_profile(self, profile_id: str) -> Optional[RulesProfile]:
        return self.profiles.get(profile_id)



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\__pycache__\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\__pycache__\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\dialogs\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\dialogs\startup_setup_dialog.py
============================================================
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QRadioButton,
    QGroupBox, QFileDialog, QLineEdit, QFormLayout, QMessageBox, QTextEdit
)

from src.services.rules.excel_loader import load_rules_xlsx
from src.services.rules.rules_types import RulesWorkbook, RulesProfile


@dataclass(frozen=True)
class StartupSetupResult:
    mode: str  # "free" | "rules"
    rules: Optional[RulesWorkbook]
    profile_id: Optional[str]
    level_labels_override: Optional[Dict[int, str]]
    institution_override: Optional[str]
    discipline_override: Optional[str]


def _norm(s: object) -> str:
    return " ".join(str(s).strip().split()) if s is not None else ""


class StartupSetupDialog(QDialog):
    """
    Startup gate:
      - Free Typing OR Rules Mode
      - If Rules Mode: user must load an Excel
      - After load: auto-detect + show everything; user can edit Institution/Discipline + level labels
    """
    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.setWindowTitle("LabelForge — Setup")
        self.setModal(True)
        self.setMinimumWidth(820)
        self.setMinimumHeight(420)

        self.rules: RulesWorkbook | None = None
        self.profile_id: str | None = None
        self.rules_path: Path | None = None

        self._build_ui()
        self._wire()
        self._refresh_enabled()

    def result_data(self) -> StartupSetupResult:
        if self.rb_free.isChecked():
            return StartupSetupResult("free", None, None, None, None, None)

        # Rules mode
        labels: Dict[int, str] = {}
        for lv, ed in self.level_edits.items():
            t = ed.text().strip()
            if t:
                labels[lv] = t

        inst = self.ed_institution.text().strip() or None
        disc = self.ed_discipline.text().strip() or None

        return StartupSetupResult(
            mode="rules",
            rules=self.rules,
            profile_id=self.profile_id,
            level_labels_override=(labels or None),
            institution_override=inst,
            discipline_override=disc,
        )

    # ---------------- UI ----------------
    def _build_ui(self) -> None:
        outer = QVBoxLayout(self)
        outer.setContentsMargins(16, 16, 16, 16)
        outer.setSpacing(10)

        title = QLabel("Choose how you want to run the app")
        title.setStyleSheet("font-size: 16px; font-weight: 600;")
        outer.addWidget(title)

        # Mode
        gb = QGroupBox("Mode")
        vb = QVBoxLayout(gb)
        self.rb_free = QRadioButton("Free Typing (no rules)")
        self.rb_rules = QRadioButton("Rules Mode (load Excel)")
        self.rb_free.setChecked(True)
        vb.addWidget(self.rb_free)
        vb.addWidget(self.rb_rules)
        outer.addWidget(gb)

        # Load strip
        strip = QHBoxLayout()
        self.lbl_file = QLabel("No Excel loaded.")
        self.lbl_file.setStyleSheet("color: #bbb;")
        self.btn_load = QPushButton("Load Excel…")
        strip.addWidget(self.lbl_file, 1)
        strip.addWidget(self.btn_load, 0)
        outer.addLayout(strip)

        # Review group
        self.gb_review = QGroupBox("Review (auto-detected)")
        form = QFormLayout(self.gb_review)
        form.setLabelAlignment(Qt.AlignLeft)

        # Institution / Discipline (examples)
        self.ed_institution = QLineEdit()
        self.ed_institution.setPlaceholderText("e.g. Vienna Natural History Museum")
        self.ed_discipline = QLineEdit()
        self.ed_discipline.setPlaceholderText("e.g. Vertebrate Collection")

        # Level labels (examples)
        self.level_edits: Dict[int, QLineEdit] = {}
        placeholders = {
            1: "e.g. Collection",
            2: "e.g. Subcollection",
            3: "e.g. Group",
            4: "e.g. Specimen",
        }
        for lv in (1, 2, 3, 4):
            ed = QLineEdit()
            ed.setPlaceholderText(placeholders.get(lv, f"Level {lv}"))
            self.level_edits[lv] = ed

            lbl = QLabel(f"Level {lv} label:")
            lbl.setMinimumWidth(110)  # prevent truncation
            lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
            form.addRow(lbl, ed)

        # Put institution/discipline first (with non-truncating labels)
        lbl_i = QLabel("Institution:")
        lbl_i.setMinimumWidth(110)
        lbl_i.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        form.insertRow(0, lbl_i, self.ed_institution)

        lbl_d = QLabel("Discipline:")
        lbl_d.setMinimumWidth(110)
        lbl_d.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        form.insertRow(1, lbl_d, self.ed_discipline)

        outer.addWidget(self.gb_review)

        # Detected config text
        self.txt_detected = QTextEdit()
        self.txt_detected.setReadOnly(True)
        self.txt_detected.setMinimumHeight(90)
        outer.addWidget(self.txt_detected)

        # Buttons
        btns = QHBoxLayout()
        btns.addStretch(1)
        self.btn_exit = QPushButton("Exit")
        self.btn_continue = QPushButton("Continue")
        self.btn_continue.setDefault(True)
        btns.addWidget(self.btn_exit)
        btns.addWidget(self.btn_continue)
        outer.addLayout(btns)

    def _wire(self) -> None:
        self.rb_free.toggled.connect(self._refresh_enabled)
        self.rb_rules.toggled.connect(self._refresh_enabled)
        self.btn_load.clicked.connect(self._on_load_excel)
        self.btn_exit.clicked.connect(self.reject)
        self.btn_continue.clicked.connect(self._on_continue)

    def _refresh_enabled(self) -> None:
        rules_on = self.rb_rules.isChecked()
        self.btn_load.setEnabled(rules_on)                   # cannot load Excel in Free mode
        self.gb_review.setEnabled(rules_on and self.rules is not None)
        self.txt_detected.setEnabled(rules_on and self.rules is not None)

        if self.rb_free.isChecked():
            self.btn_continue.setEnabled(True)
        else:
            self.btn_continue.setEnabled(self.rules is not None and self.profile_id is not None)

    def _on_load_excel(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Load Excel", str(Path.cwd()), "Excel (*.xlsx)")
        if not path:
            return

        self.rules_path = Path(path)
        self.lbl_file.setText(self.rules_path.name)
        self.lbl_file.setStyleSheet("")

        try:
            self.rules = load_rules_xlsx(path)
        except Exception as e:
            QMessageBox.critical(self, "Load Excel Failed", str(e))
            self.rules = None
            self.profile_id = None
            self.txt_detected.setPlainText("")
            self._refresh_enabled()
            return

        # Choose first profile
        pid, prof = sorted(self.rules.profiles.items(), key=lambda kv: kv[0].lower())[0]
        self.profile_id = pid

        # Auto-fill Institution/Discipline if provided by workbook (simple authority loader sets these)
        inst = (self.rules.settings.get("institution") or "").strip()
        disc = (self.rules.settings.get("discipline") or "").strip()
        if inst:
            self.ed_institution.setText(inst)
        if disc:
            self.ed_discipline.setText(disc)

        # Fill level labels
        for lv, ed in self.level_edits.items():
            ed.setText(prof.level_labels.get(lv, ""))

        # Detected summary
        delim = prof.code_delimiter or "."
        summary = []
        summary.append(f"Loaded: {self.rules_path.name}")
        summary.append(f"Profile: {prof.profile_name} ({pid})")
        summary.append(f"Levels: {prof.level_count}   | delimiter: '{delim}'")
        summary.append(f"Mappings loaded: {len(self.rules.mappings)}")
        self.txt_detected.setPlainText("\n".join(summary))

        self._refresh_enabled()

    def _on_continue(self) -> None:
        if self.rb_free.isChecked():
            self.accept()
            return

        if self.rules is None or self.profile_id is None:
            QMessageBox.warning(self, "Rules Mode", "Load an Excel file first.")
            return

        # Require at least level 1 & 2 labels (because the main UI uses them)
        if not self.level_edits[1].text().strip() or not self.level_edits[2].text().strip():
            QMessageBox.warning(self, "Missing info", "Please provide Level 1 and Level 2 labels.")
            return

        self.accept()







============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\main_window.py
============================================================
from __future__ import annotations

from PySide6.QtGui import QAction, QKeySequence
from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QMessageBox,
    QFileDialog,
)

from src.ui.qt.views.label_editor_view import LabelEditorView


class MainWindow(QMainWindow):
    """
    Current-state main window:
    - Hosts LabelEditorView (HierarchyEditor-based)
    - No legacy subcollection UI, no legacy buttons.
    """

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("NHMC Labelling")

        self.editor = LabelEditorView()
        self.setCentralWidget(self._wrap(self.editor))

        self._build_menu()
        self.statusBar().showMessage("Ready.")

    def _wrap(self, w: QWidget) -> QWidget:
        host = QWidget()
        lay = QVBoxLayout(host)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(w)
        return host

    def _build_menu(self) -> None:
        mb = self.menuBar()
        m_file = mb.addMenu("&File")
        m_help = mb.addMenu("&Help")

        act_load_excel = QAction("Load Rules Excel…", self)
        act_load_excel.setShortcut(QKeySequence("Ctrl+O"))
        act_load_excel.triggered.connect(self._load_excel)
        m_file.addAction(act_load_excel)

        act_export_pdf = QAction("Export PDF…", self)
        act_export_pdf.setShortcut(QKeySequence("Ctrl+E"))
        act_export_pdf.triggered.connect(lambda: self.editor._export_pdf_clicked())
        m_file.addAction(act_export_pdf)

        m_file.addSeparator()

        act_save_cache = QAction("Save Cache", self)
        act_save_cache.setShortcut(QKeySequence("Ctrl+S"))
        act_save_cache.triggered.connect(lambda: self.editor._save_cache_clicked())
        m_file.addAction(act_save_cache)

        m_file.addSeparator()

        act_quit = QAction("Quit", self)
        act_quit.setShortcut(QKeySequence.Quit)
        act_quit.triggered.connect(self.close)
        m_file.addAction(act_quit)

        act_about = QAction("About", self)
        act_about.triggered.connect(self._about)
        m_help.addAction(act_about)

    def _load_excel(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Load rules.xlsx", "", "Excel (*.xlsx)")
        if not path:
            return

        ok = self.editor.load_rules_from_path(path)
        if ok:
            self.statusBar().showMessage(f"Loaded Excel: {path}", 5000)
            # Force Rules Mode ON
            if self.editor.mode.currentIndex() != 1:
                self.editor.mode.setCurrentIndex(1)
        else:
            QMessageBox.warning(self, "Load failed", "Could not load the Excel rules file.")

    def _about(self) -> None:
        QMessageBox.information(
            self,
            "About",
            "NHMC Labelling\n\nTree-first label builder with Rules Mode (Excel) + Free Typing (cached autocomplete).",
        )



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\theme.py
============================================================
from __future__ import annotations

from PySide6.QtGui import QPalette, QColor
from PySide6.QtWidgets import QApplication


# Museum Dark: charcoal + warm bronze accents (serious, institutional)
MUSEUM_QSS = r"""
/* --- Global baseline --- */
* {
    font-family: "Segoe UI";
    font-size: 10pt;
}

QWidget {
    background-color: #0c0f14;   /* charcoal */
    color: #e8e2d6;              /* warm “paper” text */
}

/* ---- Titles / headers ---- */
QLabel#Title {
    font-size: 18px;
    font-weight: 800;
    color: #f2ede2;
    padding: 2px 2px 8px 2px;
}
QLabel#Status {
    color: #b9b2a6;
}

/* --- Group boxes: museum panel look --- */
QGroupBox {
    background-color: #121722;
    border: 1px solid #2a3242;
    border-radius: 12px;
    margin-top: 12px;
    padding: 12px;
}
QGroupBox::title {
    subcontrol-origin: margin;
    left: 12px;
    padding: 0 8px;
    color: #d8cfbf;
    font-weight: 700;
    letter-spacing: 0.3px;
}

/* --- Inputs (NO WHITE) --- */
QLineEdit, QComboBox, QDoubleSpinBox, QTextEdit, QPlainTextEdit {
    background-color: #0f141d;
    color: #f0eadf;
    border: 1px solid #343e51;
    border-radius: 10px;
    padding: 8px 10px;
    selection-background-color: #b08d57;  /* bronze selection */
    selection-color: #0c0f14;
}
QLineEdit:focus, QComboBox:focus, QDoubleSpinBox:focus, QTextEdit:focus, QPlainTextEdit:focus {
    border: 1px solid #b08d57; /* bronze focus ring */
}

/* Placeholder text */
QLineEdit[echoMode="0"] { /* normal line edit */
}
QLineEdit::placeholder {
    color: #8f8a80;
}

/* --- Combo dropdown + list --- */
QComboBox::drop-down { border: none; width: 28px; }
QComboBox QAbstractItemView {
    background: #0f141d;
    color: #f0eadf;
    border: 1px solid #343e51;
    selection-background-color: #b08d57;
    selection-color: #0c0f14;
}

/* --- Buttons: bronze primary, steel secondary --- */
QPushButton {
    background-color: #b08d57;   /* bronze */
    color: #0c0f14;
    border: 1px solid #b08d57;
    border-radius: 10px;
    padding: 9px 14px;
    font-weight: 800;
}
QPushButton:hover {
    background-color: #c09a61;
    border-color: #c09a61;
}
QPushButton:pressed {
    background-color: #9a7a49;
    border-color: #9a7a49;
}
QPushButton:disabled {
    background-color: #1a2130;
    color: #6f6a62;
    border: 1px solid #2a3242;
}

/* Optional: “secondary” buttons by objectName */
QPushButton#Secondary {
    background-color: #1a2130;
    color: #e8e2d6;
    border: 1px solid #343e51;
}
QPushButton#Secondary:hover {
    border: 1px solid #b08d57;
}

/* --- Checkboxes --- */
QCheckBox { spacing: 10px; color: #d8cfbf; }
QCheckBox::indicator {
    width: 16px; height: 16px;
    border-radius: 4px;
    border: 1px solid #343e51;
    background: #0f141d;
}
QCheckBox::indicator:checked {
    background: #b08d57;
    border: 1px solid #b08d57;
}

/* --- Scroll areas and scrollbars --- */
QScrollArea {
    border: 1px solid #2a3242;
    border-radius: 12px;
    background: #0c0f14;
}
QScrollBar:vertical {
    background: #0c0f14;
    width: 12px;
    margin: 8px 4px 8px 4px;
    border-radius: 6px;
}
QScrollBar::handle:vertical {
    background: #2a3242;
    min-height: 30px;
    border-radius: 6px;
}
QScrollBar::handle:vertical:hover { background: #394459; }
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }

/* --- Menus (Windows loves to ignore these unless explicit) --- */
QMenuBar { background: #121722; color: #e8e2d6; }
QMenuBar::item:selected { background: #1a2130; }
QMenu { background: #121722; color: #e8e2d6; border: 1px solid #2a3242; }
QMenu::item:selected { background: #b08d57; color: #0c0f14; }

/* --- Separators --- */
QFrame[frameShape="4"] { color: #2a3242; }
"""


def apply_museum_theme(app: QApplication) -> None:
    # Force Fusion so Windows theme can't “helpfully” turn things white.
    app.setStyle("Fusion")

    pal = QPalette()

    # Core surfaces
    pal.setColor(QPalette.Window, QColor("#0c0f14"))
    pal.setColor(QPalette.WindowText, QColor("#e8e2d6"))
    pal.setColor(QPalette.Base, QColor("#0f141d"))
    pal.setColor(QPalette.AlternateBase, QColor("#121722"))
    pal.setColor(QPalette.Text, QColor("#e8e2d6"))

    # Buttons
    pal.setColor(QPalette.Button, QColor("#121722"))
    pal.setColor(QPalette.ButtonText, QColor("#e8e2d6"))

    # Highlights (bronze)
    pal.setColor(QPalette.Highlight, QColor("#b08d57"))
    pal.setColor(QPalette.HighlightedText, QColor("#0c0f14"))

    # Tooltips
    pal.setColor(QPalette.ToolTipBase, QColor("#121722"))
    pal.setColor(QPalette.ToolTipText, QColor("#e8e2d6"))

    app.setPalette(pal)
    app.setStyleSheet(MUSEUM_QSS)



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\views\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\views\label_editor_view.py
============================================================
from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional

from PySide6.QtCore import Qt
from PySide6.QtGui import QFont
from PySide6.QtWidgets import (
    QWidget,
    QLabel,
    QLineEdit,
    QPushButton,
    QComboBox,
    QCheckBox,
    QGroupBox,
    QFileDialog,
    QMessageBox,
    QHBoxLayout,
    QVBoxLayout,
    QFormLayout,
    QDoubleSpinBox,
    QSizePolicy,
    QDialog,
)

from reportlab.lib.pagesizes import A4, A5

from src.domain.models import LabelDocument
from src.domain.units import cm_to_pt
from src.domain.normalize import expand_child_code
from src.services.cache.cache_store import load_cache, save_cache, remember, suggest
from src.services.rules.excel_loader import load_rules_xlsx
from src.services.rules.engine import lookup_mapping
from src.services.rules.rules_types import RulesWorkbook, RulesProfile
from src.services.export.pdf_exporter import export_label_pdf, PdfExportOptions
from src.ui.qt.widgets.hierarchy_editor import HierarchyEditor, LookupResult
from src.ui.qt.widgets.pdf_template_dialog import PdfTemplateDialog


class LabelEditorView(QWidget):
    def __init__(self, parent=None) -> None:
        super().__init__(parent)

        self.cache = load_cache()

        self.rules: Optional[RulesWorkbook] = None
        self.profile: Optional[RulesProfile] = None
        self.rules_path: Optional[Path] = None

        self.level_labels: Dict[int, str] = {1: "Level 1", 2: "Level 2", 3: "Level 3", 4: "Level 4"}

        # remember last chosen export settings per session
        self._last_template_id: str = "classic"
        self._last_section_title: str = ""

        self._build_ui()
        self._wire()

        self._apply_mode_ui()
        self._refresh_hierarchy_providers()

    # ---------------- UI ----------------
    def _build_ui(self) -> None:
        self.setFont(QFont("Segoe UI", 10))

        outer = QVBoxLayout(self)
        outer.setContentsMargins(12, 12, 12, 12)
        outer.setSpacing(10)

        title = QLabel("LabelForge")
        title.setObjectName("Title")
        outer.addWidget(title, 0)

        top = QGroupBox("Mode & Rules")
        top_lay = QHBoxLayout(top)
        top_lay.setContentsMargins(10, 10, 10, 10)
        top_lay.setSpacing(8)

        top_lay.addWidget(QLabel("Mode"), 0)
        self.mode = QComboBox()
        self.mode.addItems(["Free Typing (no rules)", "Rules Mode (Excel)"])
        self.mode.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.mode.setMinimumWidth(220)
        top_lay.addWidget(self.mode, 0)

        self.btn_load_rules = QPushButton("Load Excel…")
        top_lay.addWidget(self.btn_load_rules, 0)

        top_lay.addWidget(QLabel("Profile"), 0)
        self.cbo_profile = QComboBox()
        self.cbo_profile.setEnabled(False)
        self.cbo_profile.setMinimumWidth(260)
        top_lay.addWidget(self.cbo_profile, 0)

        top_lay.addStretch(1)

        self.btn_export_pdf = QPushButton("Export PDF")
        self.btn_save_cache = QPushButton("Save Cache")
        top_lay.addWidget(self.btn_export_pdf, 0)
        top_lay.addWidget(self.btn_save_cache, 0)

        outer.addWidget(top, 0)

        info = QGroupBox("Label Info")
        info_form = QFormLayout(info)
        info_form.setLabelAlignment(Qt.AlignLeft)

        self.ed_title = QLineEdit()
        self.ed_title.setPlaceholderText("e.g. Cabinet Inventory Label")
        self.ed_cab = QLineEdit()
        self.ed_cab.setPlaceholderText("e.g. Collection Room A / Cabinet 12")

        info_form.addRow("Title", self.ed_title)
        info_form.addRow("Cabinet Section", self.ed_cab)
        outer.addWidget(info, 0)

        size = QGroupBox("Label Size")
        size_form = QFormLayout(size)
        size_form.setLabelAlignment(Qt.AlignLeft)

        self.cbo_size_preset = QComboBox()
        self.cbo_size_preset.addItems(["A4 Portrait", "A4 Landscape", "A5 Portrait", "A5 Landscape"])

        self.chk_custom_size = QCheckBox("Custom size (cm)")
        self.sp_w_cm = QDoubleSpinBox()
        self.sp_w_cm.setRange(1, 100)
        self.sp_w_cm.setDecimals(1)
        self.sp_w_cm.setValue(21.0)
        self.sp_h_cm = QDoubleSpinBox()
        self.sp_h_cm.setRange(1, 100)
        self.sp_h_cm.setDecimals(1)
        self.sp_h_cm.setValue(29.7)

        size_form.addRow("Preset", self.cbo_size_preset)
        size_form.addRow(self.chk_custom_size)
        size_form.addRow("W (cm)", self.sp_w_cm)
        size_form.addRow("H (cm)", self.sp_h_cm)
        outer.addWidget(size, 0)

        content = QGroupBox("Label Content")
        content_lay = QVBoxLayout(content)
        content_lay.setContentsMargins(10, 10, 10, 10)
        content_lay.setSpacing(8)

        self.hierarchy = HierarchyEditor()
        self.hierarchy.set_level_names(self.level_labels[1], self.level_labels[2], self.level_labels[3], self.level_labels[4])
        content_lay.addWidget(self.hierarchy, 1)
        outer.addWidget(content, 1)

        footer = QHBoxLayout()
        footer.setSpacing(8)
        outer.addLayout(footer, 0)

        self.status = QLabel("Ready.")
        self.status.setObjectName("Status")
        footer.addWidget(self.status, 1)

        self._on_custom_size_toggled(self.chk_custom_size.isChecked())

    def _wire(self) -> None:
        self.mode.currentIndexChanged.connect(lambda _i: self._apply_mode_ui())
        self.btn_load_rules.clicked.connect(self._on_load_rules)
        self.cbo_profile.currentIndexChanged.connect(lambda _i: self._on_profile_changed())

        self.btn_export_pdf.clicked.connect(self._export_pdf_clicked)
        self.btn_save_cache.clicked.connect(self._save_cache_clicked)

        self.chk_custom_size.toggled.connect(self._on_custom_size_toggled)

        self.ed_title.textEdited.connect(lambda _t: self._remember_free_typing_meta())
        self.ed_cab.textEdited.connect(lambda _t: self._remember_free_typing_meta())

        self.hierarchy.set_on_change(self._on_hierarchy_changed)

    # ---------------- Helpers ----------------
    def _rules_on(self) -> bool:
        return self.mode.currentIndex() == 1 and self.rules is not None and self.profile is not None

    def _delimiter(self) -> str:
        if self.profile and getattr(self.profile, "code_delimiter", None):
            return self.profile.code_delimiter
        return "."

    def _pad_level1(self) -> int:
        try:
            if self.rules and getattr(self.rules, "settings", None):
                v = str(self.rules.settings.get("pad_level1", "2") or "2")
                n = int(v)
                return max(1, min(n, 6))
        except Exception:
            pass
        return 2

    def _on_custom_size_toggled(self, on: bool) -> None:
        self.sp_w_cm.setEnabled(on)
        self.sp_h_cm.setEnabled(on)
        self.cbo_size_preset.setEnabled(not on)

    def _current_pagesize_pts(self) -> tuple[float, float]:
        if self.chk_custom_size.isChecked():
            return (cm_to_pt(self.sp_w_cm.value()), cm_to_pt(self.sp_h_cm.value()))

        preset = self.cbo_size_preset.currentText()
        if preset == "A4 Portrait":
            return A4
        if preset == "A4 Landscape":
            w, h = A4
            return (h, w)
        if preset == "A5 Portrait":
            return A5
        if preset == "A5 Landscape":
            w, h = A5
            return (h, w)
        return A4

    # ---------------- Mode ----------------
    def _apply_mode_ui(self) -> None:
        rules_mode = (self.mode.currentIndex() == 1)
        self.btn_load_rules.setVisible(rules_mode)
        self.cbo_profile.setVisible(rules_mode)

        if not rules_mode:
            self.profile = None
            self.level_labels = {1: "Level 1", 2: "Level 2", 3: "Level 3", 4: "Level 4"}
            self.hierarchy.set_level_names(self.level_labels[1], self.level_labels[2], self.level_labels[3], self.level_labels[4])
            self.hierarchy.set_rules_normalization(".", 2)
            self.status.setText("Free Typing Mode ON.")
            self._refresh_hierarchy_providers()
        else:
            self.status.setText("Rules Mode ON. Load an Excel rules file.")
            self._refresh_hierarchy_providers()

    # ---------------- Rules loading ----------------
    def load_rules_from_path(self, path: str) -> bool:
        try:
            self.rules = load_rules_xlsx(path)
            self.rules_path = Path(path)
        except Exception as e:
            QMessageBox.critical(self, "Load Excel Failed", str(e))
            self.rules = None
            self.profile = None
            self.rules_path = None
            self.cbo_profile.clear()
            self.cbo_profile.setEnabled(False)
            self.btn_load_rules.setText("Load Excel…")
            self._refresh_hierarchy_providers()
            return False

        self.cbo_profile.blockSignals(True)
        self.cbo_profile.clear()

        try:
            profiles = getattr(self.rules, "profiles", {}) or {}
            for pid, prof in sorted(profiles.items(), key=lambda kv: str(kv[0]).lower()):
                name = getattr(prof, "profile_name", str(pid))
                self.cbo_profile.addItem(f"{name} ({pid})", userData=pid)
        finally:
            self.cbo_profile.blockSignals(False)

        self.cbo_profile.setEnabled(self.cbo_profile.count() > 0)

        if self.cbo_profile.count() > 0:
            self.cbo_profile.setCurrentIndex(0)
            self._apply_profile(self.cbo_profile.currentData())

        self.status.setText(f"Loaded Excel: {self.rules_path.name}")
        self.btn_load_rules.setText("Change Excel…")

        self._refresh_hierarchy_providers()
        return True

    def _on_load_rules(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Load rules.xlsx", str(Path.cwd()), "Excel (*.xlsx)")
        if not path:
            return
        self.load_rules_from_path(path)

    def _on_profile_changed(self) -> None:
        pid = self.cbo_profile.currentData()
        if pid:
            self._apply_profile(pid)

    def _apply_profile(self, profile_id: str) -> None:
        if not self.rules or not profile_id:
            return

        prof = self.rules.get_profile(profile_id)
        if not prof:
            return

        self.profile = prof

        labels = getattr(prof, "level_labels", {}) or {}
        self.level_labels = {
            1: labels.get(1, "Level 1"),
            2: labels.get(2, "Level 2"),
            3: labels.get(3, "Level 3"),
            4: labels.get(4, "Level 4"),
        }

        self.hierarchy.set_level_names(self.level_labels[1], self.level_labels[2], self.level_labels[3], self.level_labels[4])

        settings = getattr(self.rules, "settings", {}) or {}
        if settings.get("title_default"):
            self.ed_title.setText(settings["title_default"])

        self.status.setText(f"Profile: {getattr(prof,'profile_name','')}  | delimiter '{self._delimiter()}'")
        self.hierarchy.set_rules_normalization(self._delimiter(), self._pad_level1())
        self._refresh_hierarchy_providers()

    # ---------------- Providers ----------------
    def _refresh_hierarchy_providers(self) -> None:
        if self._rules_on():
            self.hierarchy.set_providers(self._suggest_codes_rules, self._suggest_names_rules, self._lookup_rules)
        else:
            self.hierarchy.set_providers(self._suggest_codes_free, self._suggest_names_free, None)

    def _cache_key_code(self, level: int) -> str:
        return f"lvl{level}.code"

    def _cache_key_name(self, level: int) -> str:
        return f"lvl{level}.name"

    def _suggest_codes_free(self, level: int, prefix: str) -> List[str]:
        try:
            return suggest(self.cache, self._cache_key_code(level), prefix=prefix)  # type: ignore
        except TypeError:
            return suggest(self.cache, self._cache_key_code(level), prefix)  # type: ignore
        except Exception:
            return []

    def _suggest_names_free(self, level: int, prefix: str) -> List[str]:
        try:
            return suggest(self.cache, self._cache_key_name(level), prefix=prefix)  # type: ignore
        except TypeError:
            return suggest(self.cache, self._cache_key_name(level), prefix)  # type: ignore
        except Exception:
            return []

    def _rules_scan_codes(self, level: int) -> List[str]:
        codes: List[str] = []
        if not self.rules or not self.profile:
            return codes
        try:
            for (pid, lv, _), mr in (getattr(self.rules, "mappings", {}) or {}).items():
                if pid != self.profile.profile_id or lv != level:
                    continue
                code = getattr(mr, "code", "") or ""
                if code:
                    codes.append(str(code).strip())
        except Exception:
            pass
        return sorted(set([c for c in codes if c]))

    def _rules_scan_names(self, level: int) -> List[str]:
        names: List[str] = []
        if not self.rules or not self.profile:
            return names
        try:
            for (pid, lv, _), mr in (getattr(self.rules, "mappings", {}) or {}).items():
                if pid != self.profile.profile_id or lv != level:
                    continue
                nm = getattr(mr, "name", "") or ""
                if nm:
                    names.append(str(nm).strip())
        except Exception:
            pass
        return sorted(set([n for n in names if n]))

    def _suggest_codes_rules(self, level: int, prefix: str, parent_code: str = "") -> List[str]:
        if not self._rules_on() or not self.rules or not self.profile:
            return self._suggest_codes_free(level, prefix)

        delim = self._delimiter()
        pfx = (prefix or "").strip()
        parent_code = (parent_code or "").strip()

        hist = self._suggest_codes_free(level, pfx)

        if level <= 1 or not parent_code:
            wb_codes = self._rules_scan_codes(level)
            merged = sorted(set([c for c in wb_codes if c.lower().startswith(pfx.lower())] + hist))
            return merged[:200]

        suffixes: List[str] = []
        for (pid, lv, _), mr in (getattr(self.rules, "mappings", {}) or {}).items():
            if pid != self.profile.profile_id or lv != level:
                continue
            code = str(getattr(mr, "code", "") or "")
            if not code.startswith(parent_code + delim):
                continue
            suf = code[len(parent_code + delim):]
            if suf:
                suffixes.append(suf)

        wb_suffixes = sorted(set(suffixes))
        if pfx:
            wb_suffixes = [s for s in wb_suffixes if s.lower().startswith(pfx.lower())]

        hist_suffix: List[str] = []
        for h in hist:
            hs = (h or "").strip()
            if hs.startswith(parent_code + delim):
                hs = hs[len(parent_code + delim):]
            hist_suffix.append(hs)

        merged = sorted(set(wb_suffixes + hist_suffix))
        return merged[:200]

    def _suggest_names_rules(self, level: int, prefix: str) -> List[str]:
        wb = self._rules_scan_names(level)
        hist = self._suggest_names_free(level, prefix)
        merged = sorted(set([n for n in wb if n.lower().startswith((prefix or "").lower())] + hist))
        return merged[:200]

    def _lookup_rules(self, level: int, code: str, parent_code: str = "") -> Optional[LookupResult]:
        if not self._rules_on():
            return None
        assert self.rules is not None
        assert self.profile is not None

        code_norm = (code or "").strip()
        if level == 1:
            if code_norm.isdigit():
                code_norm = str(int(code_norm)).zfill(self._pad_level1())
        else:
            code_norm = expand_child_code((parent_code or "").strip(), code_norm, self._delimiter())

        mr = lookup_mapping(self.rules, self.profile.profile_id, level, code_norm.strip())
        if mr and getattr(mr, "name", None):
            return LookupResult(name=str(mr.name), locked=bool(getattr(mr, "locked", False)))
        return None

    # ---------------- Cache ----------------
    def _on_hierarchy_changed(self, level: int, code: str, name: str) -> None:
        if code:
            remember(self.cache, self._cache_key_code(level), code, limit=500)
        if name:
            remember(self.cache, self._cache_key_name(level), name, limit=500)

    def _remember_free_typing_meta(self) -> None:
        remember(self.cache, "title", self.ed_title.text(), limit=200)
        remember(self.cache, "cabinet_section", self.ed_cab.text(), limit=200)

    # ---------------- Actions ----------------
    def _save_cache_clicked(self) -> None:
        try:
            save_cache(self.cache)
            QMessageBox.information(self, "Saved", "Cache saved.")
            self.status.setText("Cache saved.")
        except Exception as e:
            QMessageBox.critical(self, "Save Failed", str(e))
            self.status.setText("Save cache failed.")

    def _export_pdf_clicked(self) -> None:
        dlg = PdfTemplateDialog(self)
        dlg.set_sample_content(
            (self.ed_title.text() or "").strip() or "NHMC Label",
            (self.ed_cab.text() or "").strip() or "Cabinet Section: Example Cabinet A",
        )

        # restore last selections
        try:
            if self._last_template_id in dlg.radios:
                dlg.radios[self._last_template_id].setChecked(True)
                dlg._selected_template_id = self._last_template_id
            dlg.set_selected_section_title(self._last_section_title)
            dlg._update_preview()
        except Exception:
            pass

        if dlg.exec() != QDialog.DialogCode.Accepted:
            self.status.setText("Export cancelled.")
            return

        template_id = dlg.selected_template_id()
        section_title = dlg.selected_section_title()

        self._last_template_id = template_id
        self._last_section_title = section_title

        out_path, _ = QFileDialog.getSaveFileName(self, "Export PDF", "labels.pdf", "PDF (*.pdf)")
        if not out_path:
            self.status.setText("Export cancelled.")
            return

        pagesize = self._current_pagesize_pts()

        doc = LabelDocument()
        doc.title = (self.ed_title.text() or "").strip()
        doc.cabinet_section = (self.ed_cab.text() or "").strip()
        doc.hierarchy = self.hierarchy.export_entries()

        opts = PdfExportOptions(pagesize=pagesize, template_id=template_id, section_title=section_title)

        try:
            export_label_pdf(doc, out_path, opts)
            QMessageBox.information(self, "Exported", f"Exported PDF:\n{out_path}")
            label = section_title if section_title else "no section title"
            self.status.setText(f"Exported ({template_id}, {label}): {Path(out_path).name}")
        except Exception as e:
            QMessageBox.critical(self, "Export Failed", str(e))
            self.status.setText("Export failed.")



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\widgets\__init__.py
============================================================


============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\widgets\autocomplete_combo.py
============================================================
from __future__ import annotations

from PySide6.QtCore import Signal
from PySide6.QtWidgets import QComboBox


class AutoCompleteCombo(QComboBox):
    """
    Editable dropdown that updates its list as the user types.
    Supports locking (read-only behavior) for canonical rule-enforced fields.
    """
    textEdited = Signal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setEditable(True)
        self.setInsertPolicy(QComboBox.NoInsert)

        self._locked = False
        self.lineEdit().textEdited.connect(self.textEdited.emit)

    def set_suggestions(self, items: list[str]) -> None:
        cur = self.currentText()
        self.blockSignals(True)
        self.clear()
        self.addItems(items)
        self.setCurrentText(cur)
        self.blockSignals(False)

    def set_locked(self, locked: bool) -> None:
        self._locked = bool(locked)
        # lock the editor but still show value
        if self.isEditable() and self.lineEdit() is not None:
            self.lineEdit().setReadOnly(self._locked)
        self.setEnabled(True)  # keep visible even when locked



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\widgets\hierarchy_editor.py
============================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional

from PySide6.QtCore import Qt, QStringListModel
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QTreeWidget,
    QTreeWidgetItem,
    QMessageBox,
    QSizePolicy,
    QStyledItemDelegate,
    QLineEdit,
    QCompleter,
    QHeaderView,
    QStyleOptionViewItem,
)

from src.domain.normalize import expand_child_code


@dataclass
class LookupResult:
    name: str
    locked: bool = False


# Providers now accept optional parent_code (backwards compatible at runtime).
SuggestFn = Callable[..., List[str]]
LookupFn = Callable[..., Optional[LookupResult]]
ChangeFn = Callable[[int, str, str], None]


ROLE_LEVEL = Qt.UserRole
ROLE_LOCKED = Qt.UserRole + 1
ROLE_CANON_NAME = Qt.UserRole + 2


class HierarchyItemDelegate(QStyledItemDelegate):
    """
    Delegate for QTreeWidget editing:
    - Autocomplete dropdown for Code/Name (live as you type)
    - Enforces lock: when locked, Name column is not editable
    - Ensures editor geometry uses the full cell rect (prevents “chewed” typing)
    """

    def __init__(self, owner: "HierarchyEditor") -> None:
        super().__init__(owner)
        self.owner = owner

    def createEditor(self, parent, option, index):
        if not index.isValid():
            return None

        col = index.column()

        # SAFE: QTreeWidget must use itemFromIndex (internalPointer can crash in PySide)
        item = self.owner.tree.itemFromIndex(index)
        if item is None:
            item = self.owner.tree.currentItem()
        if item is None:
            return None

        locked = bool(item.data(0, ROLE_LOCKED) or False)

        # True lock: block Name editing (column 1)
        if locked and col == self.owner.COL_NAME:
            return None

        # Only Code/Name are editable
        if col not in (self.owner.COL_CODE, self.owner.COL_NAME):
            return None

        ed = QLineEdit(parent)
        ed.setClearButtonEnabled(True)
        ed.setMinimumHeight(28)
        ed.setStyleSheet("padding-left: 6px; padding-right: 6px;")

        comp = QCompleter(ed)
        comp.setCaseSensitivity(Qt.CaseInsensitive)
        comp.setFilterMode(Qt.MatchContains)
        comp.setCompletionMode(QCompleter.PopupCompletion)

        model = QStringListModel(ed)
        comp.setModel(model)
        ed.setCompleter(comp)

        # Strong refs (avoid GC + silent crashes)
        ed._ac_model = model  # type: ignore[attr-defined]
        ed._ac_comp = comp    # type: ignore[attr-defined]

        def refresh(prefix: str) -> None:
            level = self.owner._depth_of(item)
            parent_code = ""
            try:
                p = item.parent()
                if p is not None:
                    parent_code = (p.text(self.owner.COL_CODE) or "").strip()
            except Exception:
                parent_code = ""

            try:
                if col == self.owner.COL_CODE and self.owner._suggest_codes is not None:
                    try:
                        items = self.owner._suggest_codes(level, prefix or "", parent_code)
                    except TypeError:
                        items = self.owner._suggest_codes(level, prefix or "")
                elif col == self.owner.COL_NAME and self.owner._suggest_names is not None:
                    try:
                        items = self.owner._suggest_names(level, prefix or "", parent_code)
                    except TypeError:
                        items = self.owner._suggest_names(level, prefix or "")
                else:
                    items = []
            except Exception:
                items = []

            model.setStringList((items or [])[:200])

        ed.textEdited.connect(refresh)

        try:
            refresh(item.text(col) or "")
        except Exception:
            refresh("")

        return ed

    def updateEditorGeometry(self, editor, option: QStyleOptionViewItem, index) -> None:
        if editor is not None:
            editor.setGeometry(option.rect)
        else:
            super().updateEditorGeometry(editor, option, index)

    def setEditorData(self, editor, index):
        if isinstance(editor, QLineEdit):
            editor.setText(index.data(Qt.EditRole) or "")
            editor.selectAll()
            return
        super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        if isinstance(editor, QLineEdit):
            model.setData(index, editor.text(), Qt.EditRole)
            return
        super().setModelData(editor, model, index)


class HierarchyEditor(QWidget):
    """
    Tree-first hierarchy editor (Levels 1..4).
    - Semantic buttons ("Add Level 3", etc.)
    - Autocomplete in Code/Name cells
    - Rules-mode “lazy typing”:
        * Level 1: pads digits (1 -> 01) based on rules
        * Level 2+: expands suffix by parent (2 -> 01.2)
    """

    COL_CODE = 0
    COL_NAME = 1

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        self._level_names: List[str] = ["Level 1", "Level 2", "Level 3", "Level 4"]

        self._suggest_codes: Optional[SuggestFn] = None
        self._suggest_names: Optional[SuggestFn] = None
        self._lookup: Optional[LookupFn] = None
        self._on_change: Optional[ChangeFn] = None

        # Rules normalization (set by LabelEditorView in Rules Mode)
        self._code_delimiter: str = "."
        self._pad_level1: int = 2

        self._building = False

        self._build_ui()
        self._wire()

        self.tree.setItemDelegate(HierarchyItemDelegate(self))

        self.add_level1()

    # ---------------- Public API ----------------
    def set_level_names(self, level1: str, level2: str, level3: str = "Level 3", level4: str = "Level 4") -> None:
        self._level_names = [level1, level2, level3, level4]
        self._update_buttons()

    def set_providers(self, suggest_codes: Optional[SuggestFn], suggest_names: Optional[SuggestFn], lookup: Optional[LookupFn]) -> None:
        self._suggest_codes = suggest_codes
        self._suggest_names = suggest_names
        self._lookup = lookup

    def set_on_change(self, cb: Optional[ChangeFn]) -> None:
        self._on_change = cb

    def set_rules_normalization(self, delimiter: str, pad_level1: int) -> None:
        d = (delimiter or ".").strip()
        if len(d) != 1:
            d = "."
        self._code_delimiter = d
        try:
            p = int(pad_level1)
        except Exception:
            p = 2
        self._pad_level1 = max(1, min(p, 6))

    def clear(self) -> None:
        self._building = True
        self.tree.clear()
        self._building = False
        self.add_level1()

    def export_entries(self) -> List[Dict[str, Any]]:
        def walk(item: QTreeWidgetItem, level: int) -> Dict[str, Any]:
            node = {
                "level": level,
                "code": (item.text(self.COL_CODE) or "").strip(),
                "name": (item.text(self.COL_NAME) or "").strip(),
                "children": [],
            }
            for i in range(item.childCount()):
                node["children"].append(walk(item.child(i), level + 1))
            return node

        roots = []
        for i in range(self.tree.topLevelItemCount()):
            roots.append(walk(self.tree.topLevelItem(i), 1))
        return roots

    # ---------------- Buttons ----------------
    def add_level1(self) -> None:
        it = self._make_item(level=1)
        self.tree.addTopLevelItem(it)
        self.tree.setCurrentItem(it)
        self.tree.editItem(it, self.COL_CODE)
        self._update_buttons()

    def add_child(self) -> None:
        sel = self._selected_item()
        if sel is None:
            self.add_level1()
            return
        level = self._depth_of(sel)
        if level >= 4:
            self._warn("Max depth", "You cannot add deeper than Level 4.")
            return
        child = self._make_item(level=level + 1)
        sel.addChild(child)
        sel.setExpanded(True)
        self.tree.setCurrentItem(child)
        self.tree.editItem(child, self.COL_CODE)
        self._update_buttons()

    def add_sibling(self) -> None:
        sel = self._selected_item()
        if sel is None:
            self.add_level1()
            return
        parent = sel.parent()
        level = self._depth_of(sel)
        sib = self._make_item(level=level)
        if parent is None:
            self.tree.addTopLevelItem(sib)
        else:
            parent.addChild(sib)
            parent.setExpanded(True)
        self.tree.setCurrentItem(sib)
        self.tree.editItem(sib, self.COL_CODE)
        self._update_buttons()

    def remove_selected(self) -> None:
        sel = self._selected_item()
        if sel is None:
            return

        parent = sel.parent()
        if parent is None:
            idx = self.tree.indexOfTopLevelItem(sel)
            self.tree.takeTopLevelItem(idx)
        else:
            parent.removeChild(sel)

        if self.tree.topLevelItemCount() == 0:
            self.add_level1()

        self._update_buttons()

    # ---------------- Internals ----------------
    def _build_ui(self) -> None:
        lay = QVBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.setSpacing(6)

        bar = QHBoxLayout()
        bar.setSpacing(8)

        self.btn_add_child = QPushButton("Add Level 2")
        self.btn_add_sibling = QPushButton("Add Level 1")
        self.btn_remove = QPushButton("Remove")

        self.btn_add_child.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.btn_add_sibling.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.btn_remove.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)

        bar.addWidget(self.btn_add_child, 0)
        bar.addWidget(self.btn_add_sibling, 0)
        bar.addStretch(1)
        bar.addWidget(self.btn_remove, 0)

        lay.addLayout(bar, 0)

        self.tree = QTreeWidget()
        self.tree.setColumnCount(2)
        self.tree.setHeaderLabels(["Code", "Name"])
        self.tree.setUniformRowHeights(True)
        self.tree.setAlternatingRowColors(True)
        self.tree.setExpandsOnDoubleClick(True)
        self.tree.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Avoid "..." eliding
        self.tree.setTextElideMode(Qt.ElideNone)

        # Indentation matters for usable width
        self.tree.setIndentation(18)

        hdr = self.tree.header()
        hdr.setStretchLastSection(True)
        hdr.setMinimumSectionSize(160)
        hdr.setSectionResizeMode(0, QHeaderView.Interactive)
        hdr.setSectionResizeMode(1, QHeaderView.Stretch)

        self.tree.setColumnWidth(0, 220)

        lay.addWidget(self.tree, 1)

    def _wire(self) -> None:
        self.btn_add_child.clicked.connect(self.add_child)
        self.btn_add_sibling.clicked.connect(self.add_sibling)
        self.btn_remove.clicked.connect(self.remove_selected)

        self.tree.currentItemChanged.connect(lambda _a, _b: self._update_buttons())
        self.tree.itemChanged.connect(self._on_item_changed)

    def _level_name(self, level: int) -> str:
        if 1 <= level <= len(self._level_names):
            return self._level_names[level - 1]
        return f"Level {level}"

    def _update_buttons(self) -> None:
        sel = self._selected_item()
        if sel is None:
            self.btn_add_child.setText(f"Add {self._level_name(1)}")
            self.btn_add_sibling.setText(f"Add {self._level_name(1)}")
            self.btn_add_child.setEnabled(True)
            self.btn_add_sibling.setEnabled(True)
            return

        depth = self._depth_of(sel)
        next_level = min(depth + 1, 4)

        self.btn_add_child.setText(f"Add {self._level_name(next_level)}")
        self.btn_add_sibling.setText(f"Add {self._level_name(depth)}")

        self.btn_add_child.setEnabled(depth < 4)
        self.btn_add_sibling.setEnabled(True)

    def _make_item(self, level: int) -> QTreeWidgetItem:
        it = QTreeWidgetItem(["", ""])
        it.setData(0, ROLE_LEVEL, level)
        it.setData(0, ROLE_LOCKED, False)
        it.setData(0, ROLE_CANON_NAME, "")
        it.setFlags(it.flags() | Qt.ItemIsEditable | Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        return it

    def _selected_item(self) -> Optional[QTreeWidgetItem]:
        return self.tree.currentItem()

    def _depth_of(self, item: QTreeWidgetItem) -> int:
        d = 1
        p = item.parent()
        while p is not None:
            d += 1
            p = p.parent()
        return d

    def _warn(self, title: str, msg: str) -> None:
        QMessageBox.information(self, title, msg)

    def _set_locked(self, item: QTreeWidgetItem, locked: bool, canonical_name: str = "") -> None:
        item.setData(0, ROLE_LOCKED, bool(locked))
        item.setData(0, ROLE_CANON_NAME, str(canonical_name or ""))

    def _normalize_code_for_item(self, item: QTreeWidgetItem, raw_code: str) -> str:
        code = (raw_code or "").strip()
        if not code:
            return code

        level = self._depth_of(item)

        if level == 1:
            if code.isdigit():
                return str(int(code)).zfill(self._pad_level1)
            return code

        # Level 2+ : expand suffix using parent
        parent = item.parent()
        parent_code = ""
        if parent is not None:
            parent_code = (parent.text(self.COL_CODE) or "").strip()

        return expand_child_code(parent_code, code, self._code_delimiter)

    def _on_item_changed(self, item: QTreeWidgetItem, col: int) -> None:
        if self._building:
            return

        level = self._depth_of(item)
        code = (item.text(self.COL_CODE) or "").strip()
        name = (item.text(self.COL_NAME) or "").strip()

        locked = bool(item.data(0, ROLE_LOCKED) or False)

        # If locked and user tried to change Name, revert immediately
        if col == self.COL_NAME and locked:
            canon = str(item.data(0, ROLE_CANON_NAME) or "")
            if canon and name != canon:
                self._building = True
                item.setText(self.COL_NAME, canon)
                self._building = False

            if self._on_change is not None:
                try:
                    self._on_change(level, code, canon or name)
                except Exception:
                    pass
            return

        # Code edits: normalize + lookup
        if col == self.COL_CODE:
            norm = self._normalize_code_for_item(item, code)
            if norm != code:
                self._building = True
                item.setText(self.COL_CODE, norm)
                self._building = False
                code = norm

            if not code:
                self._building = True
                self._set_locked(item, False, "")
                self._building = False
            elif self._lookup is not None:
                # pass parent_code to lookup when possible
                parent_code = ""
                try:
                    p = item.parent()
                    if p is not None:
                        parent_code = (p.text(self.COL_CODE) or "").strip()
                except Exception:
                    parent_code = ""

                try:
                    try:
                        res = self._lookup(level, code, parent_code)
                    except TypeError:
                        res = self._lookup(level, code)
                except Exception:
                    res = None

                if res is not None and res.name:
                    self._building = True
                    item.setText(self.COL_NAME, res.name)
                    self._set_locked(item, bool(res.locked), res.name if res.locked else "")
                    self._building = False

        # Remember callback
        if self._on_change is not None:
            try:
                self._on_change(level, code, (item.text(self.COL_NAME) or "").strip())
            except Exception:
                pass



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\widgets\level_row_widget.py
============================================================
from __future__ import annotations

from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton
from src.ui.qt.widgets.autocomplete_combo import AutoCompleteCombo


class LevelRowWidget(QWidget):
    def __init__(self, level: int, level_label: str, parent=None):
        super().__init__(parent)
        self.level = level

        self.lbl = QLabel(level_label)
        self.cbo_code = AutoCompleteCombo()
        self.cbo_name = AutoCompleteCombo()
        self.btn_remove = QPushButton("Remove")

        lay = QHBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(self.lbl, 0)
        lay.addWidget(QLabel("Code:"), 0)
        lay.addWidget(self.cbo_code, 1)
        lay.addWidget(QLabel("Name:"), 0)
        lay.addWidget(self.cbo_name, 2)
        lay.addWidget(self.btn_remove, 0)

    def get_values(self) -> tuple[str, str]:
        return self.cbo_code.currentText().strip(), self.cbo_name.currentText().strip()

    def set_values(self, code: str, name: str) -> None:
        self.cbo_code.setCurrentText(code or "")
        self.cbo_name.setCurrentText(name or "")

    def lock_name(self, locked: bool) -> None:
        self.cbo_name.set_locked(locked)



============================================================
FILE: C:\Users\giana\Desktop\Personal\NHMC\Specify\Specify migration\NHMC-Labelling\src\ui\qt\widgets\pdf_template_dialog.py
============================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from PySide6.QtCore import Qt, QSize
from PySide6.QtGui import QPainter, QPixmap, QPen, QFont
from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QRadioButton,
    QButtonGroup,
    QGroupBox,
    QWidget,
    QComboBox,
    QLineEdit,
    QSizePolicy,
)


@dataclass(frozen=True)
class TemplateChoice:
    template_id: str
    template_name: str


TEMPLATES = [
    TemplateChoice("classic", "Classic Formal (Serif)"),
    TemplateChoice("modern", "Modern Formal (Sans)"),
    TemplateChoice("institutional", "Institutional (Header + Footer)"),
    TemplateChoice("boxed", "Boxed Sections (Formal Blocks)"),
    TemplateChoice("compact", "Compact Card (Dense Layout)"),
    TemplateChoice("code_first", "Code-First (Large Codes)"),
    TemplateChoice("outline", "Indented Outline (No Table)"),
    TemplateChoice("two_column", "Two-Column Hierarchy"),
]


class PdfTemplateDialog(QDialog):
    """
    Template chooser with fast mock preview (QPainter).
    Includes Section Title selector used by the real PDF exporter.
    """

    SECTION_PRESETS = [
        ("", "(None)"),
        ("Classification", "Classification"),
        ("Taxonomy", "Taxonomy"),
        ("Collection Path", "Collection Path"),
        ("Hierarchy", "Hierarchy"),
        ("__custom__", "Custom…"),
    ]

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Choose PDF Template")
        self.setModal(True)
        self.setMinimumWidth(920)

        self._selected_template_id = "classic"
        self._title = "NHMC Label"
        self._cabinet = "Cabinet Section: Example Cabinet A"

        # section title ("" means none)
        self._section_title: str = ""

        # sample hierarchy used in preview
        self._rows = [
            ("01", "Mammals"),
            ("01.1", "Mammals – Carnivora"),
            ("01.2", "Mammals – Herbivora"),
            ("02", "Birds"),
            ("02.1", "Birds – Passerines"),
        ]

        self._build_ui()
        self._wire()
        self._update_preview()

    # ---------- public API ----------
    def set_sample_content(self, title: str, cabinet: str) -> None:
        self._title = title or self._title
        self._cabinet = cabinet or self._cabinet
        self._update_preview()

    def selected_template_id(self) -> str:
        return self._selected_template_id

    def selected_section_title(self) -> str:
        # "" = none
        if self.cbo_section.currentData() == "__custom__":
            return (self.ed_custom.text() or "").strip()
        val = self.cbo_section.currentData()
        return (val or "").strip()

    def set_selected_section_title(self, title: str) -> None:
        """
        Restore a previous selection.
        If it doesn't match a preset, we set Custom and fill it.
        """
        t = (title or "").strip()
        # exact preset?
        for i in range(self.cbo_section.count()):
            if (self.cbo_section.itemData(i) or "") == t:
                self.cbo_section.setCurrentIndex(i)
                self.ed_custom.setText("")
                self._on_section_changed()
                return

        if t == "":
            # none
            for i in range(self.cbo_section.count()):
                if (self.cbo_section.itemData(i) or "") == "":
                    self.cbo_section.setCurrentIndex(i)
                    self.ed_custom.setText("")
                    self._on_section_changed()
                    return

        # custom
        for i in range(self.cbo_section.count()):
            if (self.cbo_section.itemData(i) or "") == "__custom__":
                self.cbo_section.setCurrentIndex(i)
                self.ed_custom.setText(t)
                self._on_section_changed()
                return

    # ---------------- UI ----------------
    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        root.setContentsMargins(12, 12, 12, 12)
        root.setSpacing(10)

        help_txt = QLabel(
            "Pick a presentation style for the exported label PDF.\n"
            "Use 'Section Title' if you want an extra heading above the hierarchy (most labels don't need it)."
        )
        help_txt.setWordWrap(True)
        root.addWidget(help_txt)

        # Section title controls
        sec_row = QHBoxLayout()
        sec_row.setSpacing(8)

        sec_row.addWidget(QLabel("Section Title:"), 0)

        self.cbo_section = QComboBox()
        self.cbo_section.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.cbo_section.setMinimumWidth(220)
        for val, label in self.SECTION_PRESETS:
            self.cbo_section.addItem(label, userData=val)
        self.cbo_section.setCurrentIndex(0)
        sec_row.addWidget(self.cbo_section, 0)

        self.ed_custom = QLineEdit()
        self.ed_custom.setPlaceholderText("Type custom section title…")
        self.ed_custom.setEnabled(False)
        self.ed_custom.setMinimumWidth(260)
        sec_row.addWidget(self.ed_custom, 0)

        sec_row.addStretch(1)
        root.addLayout(sec_row)

        mid = QHBoxLayout()
        mid.setSpacing(12)
        root.addLayout(mid, 1)

        # left template list
        box = QGroupBox("Templates")
        left = QVBoxLayout(box)
        left.setContentsMargins(10, 10, 10, 10)
        left.setSpacing(8)

        self.grp = QButtonGroup(self)
        self.radios = {}

        for i, t in enumerate(TEMPLATES):
            rb = QRadioButton(t.template_name)
            self.grp.addButton(rb, i)
            self.radios[t.template_id] = rb
            left.addWidget(rb)

        self.radios["classic"].setChecked(True)
        left.addStretch(1)

        mid.addWidget(box, 0)

        # preview
        prev_box = QGroupBox("Preview")
        prev_lay = QVBoxLayout(prev_box)
        prev_lay.setContentsMargins(10, 10, 10, 10)

        self.preview = QLabel()
        self.preview.setAlignment(Qt.AlignCenter)
        self.preview.setMinimumSize(QSize(600, 740))
        self.preview.setStyleSheet("background: #111; border: 1px solid #333;")
        prev_lay.addWidget(self.preview, 1)

        mid.addWidget(prev_box, 1)

        # buttons
        btns = QHBoxLayout()
        btns.addStretch(1)

        self.btn_cancel = QPushButton("Cancel")
        self.btn_ok = QPushButton("Use Selected Template")
        self.btn_ok.setDefault(True)

        btns.addWidget(self.btn_cancel)
        btns.addWidget(self.btn_ok)
        root.addLayout(btns)

    def _wire(self) -> None:
        self.grp.buttonClicked.connect(self._on_template_changed)
        self.cbo_section.currentIndexChanged.connect(self._on_section_changed)
        self.ed_custom.textChanged.connect(lambda _t: self._update_preview())
        self.btn_cancel.clicked.connect(self.reject)
        self.btn_ok.clicked.connect(self.accept)

    def _on_template_changed(self) -> None:
        for tid, rb in self.radios.items():
            if rb.isChecked():
                self._selected_template_id = tid
                break
        self._update_preview()

    def _on_section_changed(self) -> None:
        is_custom = (self.cbo_section.currentData() == "__custom__")
        self.ed_custom.setEnabled(is_custom)
        if not is_custom:
            self.ed_custom.setText("")
        self._update_preview()

    # ---------------- Preview rendering ----------------
    def _update_preview(self) -> None:
        pm = QPixmap(600, 740)
        pm.fill(Qt.black)

        p = QPainter(pm)
        p.setRenderHint(QPainter.Antialiasing, True)

        # paper
        paper_x, paper_y = 80, 45
        paper_w, paper_h = 440, 650
        p.setPen(QPen(Qt.white, 2))
        p.setBrush(Qt.white)
        p.drawRoundedRect(paper_x, paper_y, paper_w, paper_h, 10, 10)

        tid = (self._selected_template_id or "classic").strip().lower()
        section_title = self.selected_section_title()

        # fonts
        fam = "Segoe UI" if tid in ("modern", "compact", "two_column") else "Times New Roman"
        title_font = QFont(fam, 15, QFont.Bold, False)
        meta_font_ital = QFont(fam, 9, QFont.Normal, True)
        meta_font = QFont(fam, 9, QFont.Normal, False)
        body = QFont(fam, 9, QFont.Normal, False)
        body_b = QFont(fam, 9, QFont.Bold, False)

        left = paper_x + 22
        right = paper_x + paper_w - 22
        y = paper_y + 22

        p.setPen(Qt.black)

        if tid == "institutional":
            p.setFont(QFont(fam, 8, QFont.Normal, False))
            p.drawText(left, y - 8, right - left, 14, Qt.AlignLeft | Qt.AlignVCenter, "NHMC — Natural History Museum of Crete")

        p.setFont(title_font)
        p.drawText(paper_x, y, paper_w, 26, Qt.AlignHCenter | Qt.AlignVCenter, (self._title or "")[:42])
        y += 28

        p.setFont(meta_font_ital if tid in ("classic", "boxed", "institutional") else meta_font)
        p.drawText(paper_x, y, paper_w, 18, Qt.AlignHCenter | Qt.AlignVCenter, (self._cabinet or "")[:54])
        y += 18

        if tid != "boxed":
            p.setPen(QPen(Qt.black, 1))
            p.drawLine(left, y + 10, right, y + 10)
            y += 26

        # Helpers
        def draw_section_title(y0: int, default_label: str) -> int:
            nonlocal section_title
            if (section_title or "").strip():
                label = section_title.strip()
            else:
                label = default_label

            # If user chose none, do nothing.
            if label.strip() == "":
                return y0

            p.setFont(QFont(body.family(), 10, QFont.Bold, False))
            p.drawText(left, y0, right - left, 18, Qt.AlignLeft | Qt.AlignVCenter, label)
            return y0 + 20

        def draw_table(y0: int, code_scale: float = 1.0, dense: bool = False, boxed: bool = False) -> int:
            y = y0
            if boxed:
                # cabinet block
                p.setPen(QPen(Qt.black, 1))
                p.setBrush(Qt.NoBrush)
                p.drawRoundedRect(left - 6, y - 10, (right - left) + 12, 70, 6, 6)
                p.setFont(body_b)
                p.drawText(left, y, right - left, 16, Qt.AlignLeft | Qt.AlignVCenter, "Cabinet Section")
                p.setFont(body)
                p.drawText(left, y + 16, right - left, 16, Qt.AlignLeft | Qt.AlignVCenter, (self._cabinet or "")[:60])
                y += 80

                y = draw_section_title(y, "")  # boxed doesn't need default
                # table box
                p.drawRoundedRect(left - 6, y - 10, (right - left) + 12, 240, 6, 6)
                y += 8
            else:
                # table-family: section title optional, default none
                y = draw_section_title(y, "")

            # column headers
            p.setFont(body_b)
            p.drawText(left, y, 140, 16, Qt.AlignLeft | Qt.AlignVCenter, "Code")
            p.drawText(left + 160, y, right - (left + 160), 16, Qt.AlignLeft | Qt.AlignVCenter, "Name")
            y += 14
            p.setPen(QPen(Qt.black, 1))
            p.drawLine(left, y + 4, right, y + 4)
            y += 12
            p.setPen(Qt.black)

            row_h = 18 if not dense else 14
            for code, name in self._rows[:5]:
                cfont = QFont(body.family(), int(9 * code_scale), QFont.Bold if code_scale > 1.0 else QFont.Normal, False)
                p.setFont(cfont)
                p.drawText(left, y, 150, row_h, Qt.AlignLeft | Qt.AlignVCenter, code)

                p.setFont(body)
                p.drawText(left + 160, y, right - (left + 160), row_h, Qt.AlignLeft | Qt.AlignVCenter, name)
                y += row_h
                p.setPen(QPen(Qt.black, 1))
                p.drawLine(left, y + 2, right, y + 2)
                p.setPen(Qt.black)
                y += (6 if not dense else 4)

            return y

        def draw_outline(y0: int) -> int:
            y = y0
            # outline: default title is "Classification (Outline)" unless user set none/custom
            y = draw_section_title(y, "Classification (Outline)")
            y += 4

            p.setFont(body)
            for code, name in self._rows[:5]:
                indent = 0
                if "." in code:
                    indent = 14
                if code.count(".") >= 2:
                    indent = 28
                line = f"• {code}  —  {name}"
                p.drawText(left + indent, y, right - left - indent, 16, Qt.AlignLeft | Qt.AlignVCenter, line)
                y += 18
            return y

        def draw_two_column(y0: int) -> int:
            y = y0
            y = draw_section_title(y, "")  # default none
            y += 2

            col_mid = left + (right - left) / 2.0
            p.setFont(body_b)
            p.drawText(left, y, 140, 16, Qt.AlignLeft | Qt.AlignVCenter, "Code")
            p.drawText(left + 110, y, col_mid - (left + 110), 16, Qt.AlignLeft | Qt.AlignVCenter, "Name")
            p.drawText(col_mid + 10, y, 140, 16, Qt.AlignLeft | Qt.AlignVCenter, "Code")
            p.drawText(col_mid + 120, y, right - (col_mid + 120), 16, Qt.AlignLeft | Qt.AlignVCenter, "Name")
            y += 18
            p.setPen(QPen(Qt.black, 1))
            p.drawLine(left, y, right, y)
            y += 12
            p.setPen(Qt.black)

            p.setFont(body)
            row_h = 16
            items = self._rows[:6]
            left_items = items[:3]
            right_items = items[3:6]

            yy = y
            for i in range(3):
                if i < len(left_items):
                    c, n = left_items[i]
                    p.drawText(left, yy, 110, row_h, Qt.AlignLeft | Qt.AlignVCenter, c)
                    p.drawText(left + 110, yy, col_mid - (left + 110), row_h, Qt.AlignLeft | Qt.AlignVCenter, n)
                if i < len(right_items):
                    c, n = right_items[i]
                    p.drawText(col_mid + 10, yy, 110, row_h, Qt.AlignLeft | Qt.AlignVCenter, c)
                    p.drawText(col_mid + 120, yy, right - (col_mid + 120), row_h, Qt.AlignLeft | Qt.AlignVCenter, n)
                yy += row_h + 6

            return yy

        # render by template
        if tid == "boxed":
            draw_table(y + 6, boxed=True)
        elif tid == "compact":
            draw_table(y, dense=True)
        elif tid == "code_first":
            draw_table(y, code_scale=1.2)
        elif tid == "outline":
            draw_outline(y)
        elif tid == "two_column":
            draw_two_column(y)
        else:
            draw_table(y)

        if tid == "institutional":
            p.setFont(QFont(fam, 8, QFont.Normal, False))
            p.drawText(left, paper_y + paper_h - 16, right - left, 14, Qt.AlignLeft | Qt.AlignVCenter, "Generated by NHMC-Labelling")
            p.drawText(left, paper_y + paper_h - 16, right - left, 14, Qt.AlignRight | Qt.AlignVCenter, "Page 1")

        p.end()
        self.preview.setPixmap(pm)

